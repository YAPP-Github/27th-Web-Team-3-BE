# Phase 3: AI 코드 수정 및 테스트

## 1. 목표 및 범위

### 목표
모니터링 시스템(Phase 1~2)에서 감지된 에러를 AI가 자동으로 분석하고, 안전한 범위 내에서 코드를 수정한 후, 테스트를 통해 검증하는 자동화 파이프라인을 구축합니다.

### 범위

#### 자동 수정 대상 (In Scope)
| 카테고리 | 설명 | 예시 |
|----------|------|------|
| 타입 에러 | 직렬화/역직렬화 불일치 | JSON camelCase 누락 |
| 검증 에러 | 입력 유효성 검사 누락 | 필수 필드 검증 미흡 |
| 간단한 로직 버그 | 명확한 원인의 버그 | null 체크 누락 |
| 의존성 에러 | 외부 API 응답 형식 변경 | OpenAI 응답 파싱 에러 |
| 포맷팅 이슈 | 코드 스타일 불일치 | clippy 경고 |

#### 수동 검토 필요 (Out of Scope)
| 카테고리 | 이유 |
|----------|------|
| 비즈니스 로직 변경 | 요구사항 확인 필요 |
| 데이터베이스 스키마 변경 | 마이그레이션 영향도 검토 필요 |
| API 인터페이스 변경 | 클라이언트 호환성 검토 필요 |
| 보안 관련 수정 | 보안 전문가 검토 필요 |
| 성능 최적화 | 벤치마크 및 부하 테스트 필요 |

---

## 2. AI 코드 수정 시스템

### 2.1 Claude Code 활용 방안

#### 아키텍처
```
┌─────────────────────────────────────────────────────────────────┐
│                    AI 코드 수정 파이프라인                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐       │
│  │   에러 분석   │───▶│   수정 생성   │───▶│  테스트 검증  │       │
│  │   (Phase 2)  │    │ (Claude Code)│    │  (CI/Local)  │       │
│  └──────────────┘    └──────────────┘    └──────────────┘       │
│         │                   │                   │                │
│         ▼                   ▼                   ▼                │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐       │
│  │  컨텍스트    │    │   코드 패치   │    │   PR 생성    │       │
│  │   수집       │    │    적용      │    │   (GitHub)   │       │
│  └──────────────┘    └──────────────┘    └──────────────┘       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### Claude Code CLI 활용
```bash
# 에러 분석 및 수정 요청
claude-code --prompt "
에러 정보:
- 파일: src/domain/ai/service.rs
- 에러: ValidationError at line 45
- 메시지: 'content' field is required

프로젝트 컨벤션:
- CLAUDE.md 규칙 준수
- Result<T, AppError> 반환
- serde camelCase 사용

수정 요청:
1. 에러 원인 분석
2. 최소 범위 수정 제안
3. 테스트 코드 포함
"
```

#### 자동화 스크립트 예시
```bash
#!/bin/bash
# scripts/ai-fix.sh

set -e

ERROR_FILE=$1
# 스크립트 위치 기준으로 프로젝트 루트 결정
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# 1. 에러 컨텍스트 수집
cd "$PROJECT_ROOT/codes/server"

# 2. Claude Code로 수정 생성
claude-code --cwd "$PROJECT_ROOT" \
  --context-file "$ERROR_FILE" \
  --rules-dir ".claude/rules" \
  --max-changes 3 \
  --dry-run

# 3. 사용자 승인 대기
read -p "Apply changes? (y/n): " confirm
if [ "$confirm" = "y" ]; then
  # 4. 수정 적용 및 테스트
  claude-code --apply
  cargo test
  cargo clippy -- -D warnings
fi
```

### 2.2 코드 수정 범위 제한 및 안전장치

#### 수정 범위 제한
```yaml
# .claude/config/fix-limits.yaml
limits:
  max_files_per_fix: 3          # 한 번에 수정 가능한 파일 수
  max_lines_per_file: 50        # 파일당 최대 수정 라인
  max_functions_modified: 2     # 수정 가능한 함수 수

allowed_paths:
  - "codes/server/src/domain/**/*.rs"
  - "codes/server/src/utils/**/*.rs"

forbidden_paths:
  - "codes/server/src/main.rs"
  - "codes/server/src/config/**"
  - "**/*.sql"
  - "**/*.env*"
  - "**/migrations/**"

forbidden_operations:
  - "delete_file"
  - "rename_file"
  - "modify_cargo_toml"
  - "modify_database_schema"
```

#### 안전장치 체크리스트
```rust
// 수정 전 검증 항목
pub struct SafetyChecks {
    // 필수 검증
    pub syntax_valid: bool,           // 문법 오류 없음
    pub compiles: bool,               // 컴파일 성공
    pub tests_pass: bool,             // 기존 테스트 통과
    pub no_security_impact: bool,     // 보안 영향 없음

    // 권장 검증
    pub clippy_clean: bool,           // Clippy 경고 없음
    pub coverage_maintained: bool,     // 커버리지 유지
    pub no_breaking_changes: bool,    // API 호환성 유지
}
```

#### Git 브랜치 전략
```bash
# 자동 수정 브랜치 네이밍
ai-fix/{error-id}/{timestamp}

# 예시
ai-fix/ERR-001/2026-02-01-143025

# 브랜치 생성 및 수정 적용
git checkout -b "ai-fix/ERR-001/$(date +%Y%m%d-%H%M%S)"
# ... 수정 적용 ...
git add -p  # 선택적 스테이징
git commit -m "fix: AI 자동 수정 - ERR-001

- 에러: ValidationError in service.rs
- 원인: content 필드 검증 누락
- 수정: validate() 호출 추가

Generated by: Claude Code
Error-ID: ERR-001
"
```

### 2.3 코딩 컨벤션 준수 방안

#### 컨텍스트 주입
```markdown
# AI 수정 요청 시 포함할 컨텍스트

## 필수 파일
1. CLAUDE.md - 프로젝트 규칙
2. .claude/rules/rust-src.md - Rust 코딩 규칙
3. .claude/rules/api-design.md - API 설계 규칙
4. docs/ai-conventions/claude.md - AI 협업 가이드

## 관련 코드
- 수정 대상 파일 전체
- 동일 모듈의 관련 파일 (handler.rs, service.rs, dto.rs)
- 테스트 파일

## 에러 컨텍스트
- 에러 메시지 전문
- 스택 트레이스
- 요청/응답 샘플 (민감정보 마스킹)
```

#### 컨벤션 검증 자동화
```bash
#!/bin/bash
# scripts/verify-conventions.sh

echo "=== 컨벤션 검증 시작 ==="

# 1. unwrap/expect 사용 검사 (테스트 파일 제외)
echo "1. unwrap/expect 검사..."
if grep -r "\.unwrap()\|\.expect(" codes/server/src/ --include="*.rs" | grep -v test; then
  echo "ERROR: unwrap/expect 사용 감지"
  exit 1
fi

# 2. serde camelCase 검사
echo "2. serde camelCase 검사..."
if grep -r "struct.*Request\|struct.*Response" codes/server/src/ --include="*.rs" -A 1 | \
   grep "pub struct" | grep -v "rename_all"; then
  echo "WARNING: camelCase 누락 가능성"
fi

# 3. Result 반환 검사
echo "3. Result 반환 타입 검사..."
if grep -r "pub async fn\|pub fn" codes/server/src/domain/ --include="*.rs" | \
   grep -v "Result<" | grep -v "test"; then
  echo "WARNING: Result 반환 타입 누락 가능성"
fi

echo "=== 컨벤션 검증 완료 ==="
```

---

## 3. 자동 테스트 실행

### 3.1 테스트 명령어

#### 기본 테스트 실행
```bash
# 작업 디렉토리 이동 (프로젝트 루트에서 실행 가정)
cd codes/server

# 전체 테스트 실행
cargo test

# 특정 테스트 실행
cargo test test_name

# 출력 포함 실행
cargo test -- --nocapture

# 실패한 테스트만 재실행
cargo test -- --failed
```

#### 테스트 결과 파싱
```bash
#!/bin/bash
# scripts/run-tests.sh

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$PROJECT_ROOT/codes/server"

# 테스트 실행 및 결과 저장
cargo test 2>&1 | tee /tmp/test-results.log

# 결과 파싱
PASSED=$(grep -c "ok$" /tmp/test-results.log || echo "0")
FAILED=$(grep -c "FAILED$" /tmp/test-results.log || echo "0")
IGNORED=$(grep -c "ignored$" /tmp/test-results.log || echo "0")

echo "================================================"
echo "테스트 결과 요약"
echo "================================================"
echo "통과: $PASSED"
echo "실패: $FAILED"
echo "무시: $IGNORED"
echo "================================================"

# 실패 시 상세 정보 출력
if [ "$FAILED" -gt 0 ]; then
  echo ""
  echo "실패한 테스트 목록:"
  grep "FAILED" /tmp/test-results.log
  exit 1
fi
```

### 3.2 품질 검사

#### Clippy 린트 검사
```bash
# 경고를 에러로 처리 (CI와 동일)
cargo clippy -- -D warnings

# 자동 수정 적용
cargo clippy --fix --allow-dirty

# 특정 린트 무시 (필요시)
cargo clippy -- -A clippy::too_many_arguments
```

#### 포맷팅 검사
```bash
# 포맷팅 검사만 (수정 없음)
cargo fmt --check

# 포맷팅 자동 적용
cargo fmt

# 특정 파일만 포맷팅
cargo fmt -- src/domain/ai/service.rs
```

#### 통합 품질 검사 스크립트
```bash
#!/bin/bash
# scripts/quality-check.sh

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$PROJECT_ROOT/codes/server"

echo "=== 품질 검사 시작 ==="

# 1. 포맷팅 검사
echo "[1/4] 포맷팅 검사..."
if ! cargo fmt --check; then
  echo "포맷팅 필요 - 자동 적용 중..."
  cargo fmt
  echo "포맷팅 완료"
fi

# 2. Clippy 검사
echo "[2/4] Clippy 검사..."
cargo clippy -- -D warnings

# 3. 빌드 검사
echo "[3/4] 빌드 검사..."
cargo build

# 4. 테스트 실행
echo "[4/4] 테스트 실행..."
cargo test

echo "=== 품질 검사 완료: 모든 검사 통과 ==="
```

---

## 4. 수정 검증 프로세스

### 4.1 검증 단계

```
┌─────────────────────────────────────────────────────────────────┐
│                      수정 검증 파이프라인                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [1] 문법 검증 ──▶ [2] 컴파일 ──▶ [3] 테스트 ──▶ [4] 품질 검사   │
│       │              │              │              │             │
│       ▼              ▼              ▼              ▼             │
│  cargo check    cargo build   cargo test    clippy/fmt          │
│       │              │              │              │             │
│       └──────────────┴──────────────┴──────────────┘             │
│                              │                                   │
│                              ▼                                   │
│                    [5] 회귀 테스트 (선택)                         │
│                              │                                   │
│                              ▼                                   │
│                    [6] PR 생성 / 수동 검토                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 4.2 자동 검증 스크립트

```bash
#!/bin/bash
# scripts/verify-fix.sh

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$PROJECT_ROOT/codes/server"

echo "=== AI 수정 검증 시작 ==="
echo "대상 브랜치: $(git branch --show-current)"
echo ""

# 1단계: 문법 검증
echo "[1/5] 문법 검증..."
if ! cargo check 2>/dev/null; then
  echo "FAILED: 문법 오류 발견"
  exit 1
fi
echo "PASSED"

# 2단계: 컴파일 검증
echo "[2/5] 컴파일 검증..."
if ! cargo build 2>/dev/null; then
  echo "FAILED: 컴파일 실패"
  exit 1
fi
echo "PASSED"

# 3단계: 테스트 검증
echo "[3/5] 테스트 검증..."
TEST_OUTPUT=$(cargo test 2>&1)
if echo "$TEST_OUTPUT" | grep -q "FAILED"; then
  echo "FAILED: 테스트 실패"
  echo "$TEST_OUTPUT" | grep "FAILED"
  exit 1
fi
echo "PASSED"

# 4단계: Clippy 검증
echo "[4/5] Clippy 검증..."
if ! cargo clippy -- -D warnings 2>/dev/null; then
  echo "FAILED: Clippy 경고 발견"
  exit 1
fi
echo "PASSED"

# 5단계: 포맷팅 검증
echo "[5/5] 포맷팅 검증..."
if ! cargo fmt --check 2>/dev/null; then
  echo "FAILED: 포맷팅 불일치"
  exit 1
fi
echo "PASSED"

echo ""
echo "=== 모든 검증 통과 ==="
echo "수정을 적용해도 안전합니다."
```

### 4.3 PR 자동 생성

```bash
#!/bin/bash
# scripts/create-fix-pr.sh

ERROR_ID=$1
FIX_DESCRIPTION=$2

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$PROJECT_ROOT"

# 변경 사항 확인
if [ -z "$(git status --porcelain)" ]; then
  echo "변경 사항이 없습니다."
  exit 0
fi

# 브랜치 생성
BRANCH_NAME="ai-fix/${ERROR_ID}/$(date +%Y%m%d-%H%M%S)"
git checkout -b "$BRANCH_NAME"

# 변경 사항 커밋
git add codes/server/src/
git commit -m "$(cat <<EOF
fix: AI 자동 수정 - ${ERROR_ID}

${FIX_DESCRIPTION}

Generated by: Claude Code
Error-ID: ${ERROR_ID}
Verified: All tests passed

Co-Authored-By: Claude Code <noreply@anthropic.com>
EOF
)"

# 원격 푸시
git push -u origin "$BRANCH_NAME"

# PR 생성
gh pr create \
  --title "fix: AI 자동 수정 - ${ERROR_ID}" \
  --body "$(cat <<EOF
## Summary
- AI가 자동으로 감지하고 수정한 버그 픽스입니다.
- Error ID: ${ERROR_ID}

## Changes
${FIX_DESCRIPTION}

## Verification
- [x] cargo check 통과
- [x] cargo build 통과
- [x] cargo test 통과
- [x] cargo clippy 통과
- [x] cargo fmt 통과

## Notes
- 이 PR은 AI에 의해 자동 생성되었습니다.
- 수동 리뷰 후 머지해 주세요.

---
Generated with Claude Code
EOF
)" \
  --base dev \
  --draft

echo "PR이 생성되었습니다."
```

---

## 5. 롤백 전략

### 5.1 롤백 시나리오

| 시나리오 | 롤백 방법 | 자동화 수준 |
|----------|----------|------------|
| 검증 실패 | 브랜치 삭제 | 자동 |
| 테스트 실패 | git reset --hard | 자동 |
| 배포 후 에러 | git revert | 수동 승인 |
| 성능 저하 | 이전 버전 재배포 | 수동 승인 |

### 5.2 자동 롤백 스크립트

```bash
#!/bin/bash
# scripts/rollback-fix.sh

BRANCH_NAME=$1

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$PROJECT_ROOT"

echo "=== 롤백 시작: $BRANCH_NAME ==="

# 현재 브랜치 확인
CURRENT_BRANCH=$(git branch --show-current)

if [ "$CURRENT_BRANCH" = "$BRANCH_NAME" ]; then
  # 원래 브랜치로 복귀
  git checkout dev
fi

# 로컬 브랜치 삭제
if git branch --list | grep -q "$BRANCH_NAME"; then
  git branch -D "$BRANCH_NAME"
  echo "로컬 브랜치 삭제 완료"
fi

# 원격 브랜치 삭제 (존재하는 경우)
if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
  git push origin --delete "$BRANCH_NAME"
  echo "원격 브랜치 삭제 완료"
fi

# PR 닫기 (존재하는 경우)
PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --json number -q '.[0].number')
if [ -n "$PR_NUMBER" ]; then
  gh pr close "$PR_NUMBER" --comment "AI 자동 수정 롤백됨"
  echo "PR #$PR_NUMBER 닫기 완료"
fi

echo "=== 롤백 완료 ==="
```

### 5.3 롤백 트리거 조건

```yaml
# .claude/config/rollback-triggers.yaml
auto_rollback:
  # 즉시 롤백 (자동)
  immediate:
    - test_failure_count: 1        # 테스트 1개 이상 실패
    - compile_error: true          # 컴파일 에러
    - security_issue_detected: true # 보안 이슈 감지

  # 검토 후 롤백 (수동 승인)
  review_required:
    - performance_degradation: "> 10%"
    - api_response_time: "> 500ms"
    - error_rate_increase: "> 1%"
```

---

## 6. 구현 체크리스트

### 6.1 인프라 준비
- [ ] Claude Code CLI 설치 및 설정
- [ ] GitHub Actions 워크플로우 설정
- [ ] 알림 시스템 연동 (Slack/Discord)
- [ ] 모니터링 대시보드 구성

### 6.2 스크립트 구현
- [ ] `scripts/ai-fix.sh` - AI 수정 실행
- [ ] `scripts/verify-fix.sh` - 수정 검증
- [ ] `scripts/quality-check.sh` - 품질 검사
- [ ] `scripts/create-fix-pr.sh` - PR 생성
- [ ] `scripts/rollback-fix.sh` - 롤백

### 6.3 설정 파일
- [ ] `.claude/config/fix-limits.yaml` - 수정 제한
- [ ] `.claude/config/rollback-triggers.yaml` - 롤백 조건
- [ ] `.github/workflows/ai-fix.yml` - CI 워크플로우

### 6.4 문서화
- [ ] 운영 가이드 작성
- [ ] 트러블슈팅 가이드 작성
- [ ] 에스컬레이션 프로세스 정의

### 6.5 테스트
- [ ] 단위 테스트 시나리오 검증
- [ ] 통합 테스트 시나리오 검증
- [ ] 롤백 시나리오 검증
- [ ] 엣지 케이스 검증

---

## 7. 테스트 시나리오

### 7.1 성공 시나리오

#### 시나리오 1: 간단한 검증 에러 수정
```markdown
**조건**:
- 에러: ValidationError - 필드 검증 누락
- 파일: src/domain/ai/dto.rs

**예상 동작**:
1. AI가 에러 분석 → validate 어노테이션 누락 감지
2. 수정 제안: `#[validate(length(min = 1))]` 추가
3. 테스트 실행 → 통과
4. PR 생성

**검증 방법**:
cargo test should_validate_request
```

#### 시나리오 2: serde 직렬화 에러 수정
```markdown
**조건**:
- 에러: JSON 파싱 에러 - camelCase 불일치
- 파일: src/domain/ai/dto.rs

**예상 동작**:
1. AI가 에러 분석 → rename_all 누락 감지
2. 수정 제안: `#[serde(rename_all = "camelCase")]` 추가
3. 테스트 실행 → 통과
4. PR 생성

**검증 방법**:
cargo test should_serialize_to_camel_case
```

### 7.2 실패 시나리오

#### 시나리오 3: 수정 범위 초과
```markdown
**조건**:
- 에러: 복잡한 비즈니스 로직 버그
- 예상 수정: 5개 파일, 100+ 라인

**예상 동작**:
1. AI가 에러 분석
2. 수정 범위 초과 감지
3. 자동 수정 중단
4. 수동 검토 요청 알림

**검증 방법**:
수정 범위 제한 로그 확인
```

#### 시나리오 4: 테스트 실패로 인한 롤백
```markdown
**조건**:
- AI 수정 적용 후 기존 테스트 실패

**예상 동작**:
1. 수정 적용
2. cargo test 실행 → 실패
3. 자동 롤백 실행
4. 알림 발송

**검증 방법**:
git log --oneline  # 롤백 확인
```

### 7.3 엣지 케이스

#### 시나리오 5: 동시 수정 충돌
```markdown
**조건**:
- 같은 파일에 대해 두 개의 AI 수정 요청

**예상 동작**:
1. 첫 번째 수정 진행
2. 두 번째 수정 대기
3. 충돌 감지 시 수동 검토 요청

**검증 방법**:
동시 실행 테스트 후 Git 상태 확인
```

#### 시나리오 6: 보안 민감 파일 수정 시도
```markdown
**조건**:
- 에러가 config.rs 또는 .env 관련 파일에서 발생

**예상 동작**:
1. AI가 에러 분석
2. 금지 경로 감지
3. 자동 수정 거부
4. 수동 검토 요청 알림

**검증 방법**:
forbidden_paths 로그 확인
```

---

## 8. 모니터링 지표

### 8.1 핵심 지표 (KPIs)

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| 자동 수정 성공률 | > 80% | 성공 PR / 전체 시도 |
| 평균 수정 시간 | < 5분 | 에러 감지 ~ PR 생성 |
| 롤백 비율 | < 5% | 롤백 수 / 머지된 PR |
| 테스트 통과율 | 100% | 검증 통과 / 전체 시도 |

### 8.2 알림 설정

```yaml
# 알림 조건
notifications:
  slack:
    - event: "fix_completed"
      channel: "#dev-ai-automation"
    - event: "fix_failed"
      channel: "#dev-alerts"
    - event: "manual_review_required"
      channel: "#dev-review"
      mention: "@backend-team"
```

---

## 9. 향후 개선 계획

### Phase 3.1: 기본 구현
- Claude Code CLI 연동
- 기본 수정/검증 파이프라인
- PR 자동 생성

### Phase 3.2: 고도화
- 학습 기반 수정 패턴 최적화
- 자동 롤백 고도화
- 성능 모니터링 연동

### Phase 3.3: 확장
- 다른 언어/프레임워크 지원
- 커스텀 린트 규칙 적용
- A/B 테스트 지원
