# 모니터링 도구 비교 및 선택 가이드

## 왜 모니터링이 필요한가?

```
운영 중인 서비스에서 발생하는 문제를 빠르게 감지하고 대응하기 위해

[문제 발생] → [감지] → [알림] → [진단] → [해결]
     ?분        ?분      ?분      ?분      ?분

목표: 각 단계의 시간을 최소화
```

### 모니터링의 3가지 축

| 축 | 설명 | 도구 예시 |
|---|------|----------|
| **Metrics** | 수치 데이터 (CPU, 메모리, 요청 수, 응답 시간) | Prometheus, CloudWatch Metrics, Datadog |
| **Logs** | 이벤트 기록 (에러 로그, 접근 로그, 감사 로그) | Loki, CloudWatch Logs, ELK Stack |
| **Traces** | 요청 흐름 추적 (분산 시스템에서 요청이 어디를 거쳤는지) | Jaeger, Zipkin, AWS X-Ray |

이 프로젝트는 **Logs 중심**으로 시작하고, 필요에 따라 Metrics/Traces를 확장합니다.

---

## 모니터링 도구 비교

### 1. 로그 수집/저장

| 도구 | 특징 | 비용 | 적합한 경우 |
|------|------|------|------------|
| **파일 로그** | 가장 단순, 서버에 직접 저장 | 무료 | MVP, 단일 서버 |
| **Loki** | Grafana Labs, 라벨 기반 인덱싱 | 무료 (셀프호스팅) | 비용 민감, K8s 환경 |
| **ELK Stack** | Elasticsearch 기반, 풀텍스트 검색 | 무료~높음 | 복잡한 로그 분석 필요 |
| **CloudWatch Logs** | AWS 네이티브, 설정 간편 | 중간 | AWS 환경 |
| **Datadog Logs** | SaaS, 강력한 분석 | 높음 | 엔터프라이즈 |

#### 파일 로그 (MVP 선택)
```
장점:
- 설정 없이 바로 사용
- 비용 0
- 디버깅 시 직접 확인 가능

단점:
- 서버 장애 시 로그 유실
- 다중 서버에서 집계 어려움
- 검색/분석 기능 없음

적합: 초기 스타트업, MVP, 단일 서버
```

#### Loki (추천 - Production)
```
장점:
- Grafana와 완벽 통합
- 라벨 기반으로 저비용 (전체 인덱싱 안함)
- Prometheus와 같은 쿼리 문법 (LogQL)

단점:
- 풀텍스트 검색 약함
- 셀프호스팅 필요 (또는 Grafana Cloud)

적합: 비용 효율 중시, 이미 Grafana 사용 중
```

#### CloudWatch Logs
```
장점:
- AWS 서비스와 자동 통합
- 설정 매우 간편
- Logs Insights로 쿼리 가능

단점:
- AWS 종속
- 비용이 쌓임 (저장량, 쿼리량)
- 대시보드 기능 제한적

적합: AWS 올인, 간편함 우선
```

#### ELK Stack (Elasticsearch + Logstash + Kibana)
```
장점:
- 강력한 풀텍스트 검색
- 복잡한 분석/시각화
- 오픈소스

단점:
- 운영 복잡도 높음
- 리소스 많이 사용
- 인덱싱 비용 높음

적합: 대규모 로그 분석, 검색 중심
```

---

### 2. 메트릭 수집

| 도구 | 특징 | 비용 | 적합한 경우 |
|------|------|------|------------|
| **Prometheus** | 풀 방식, 시계열 DB | 무료 | K8s, 마이크로서비스 |
| **CloudWatch Metrics** | AWS 네이티브, 푸시 방식 | 중간 | AWS 환경 |
| **Datadog** | SaaS, 올인원 | 높음 | 엔터프라이즈 |
| **InfluxDB** | 시계열 특화 | 무료~중간 | IoT, 고빈도 데이터 |

#### Prometheus (추천)
```
장점:
- 사실상 표준 (CNCF 프로젝트)
- PromQL 강력함
- 알림 규칙 설정 (Alertmanager)
- Grafana와 완벽 통합

단점:
- 풀 방식이라 방화벽 설정 필요
- 장기 저장은 별도 솔루션 필요 (Thanos, Cortex)

적합: 대부분의 경우, 특히 K8s
```

#### CloudWatch Metrics
```
장점:
- EC2, RDS 등 자동 수집
- 알람 설정 간편
- 별도 인프라 불필요

단점:
- 커스텀 메트릭 비용
- 쿼리 제한적
- 고해상도 메트릭 비용 높음

적합: AWS 환경, 기본 모니터링
```

---

### 3. APM (Application Performance Monitoring)

| 도구 | 특징 | 비용 | 적합한 경우 |
|------|------|------|------------|
| **Sentry** | 에러 추적 특화, 소스맵 지원 | 무료~중간 | 에러 모니터링 |
| **Datadog APM** | 풀스택 APM | 높음 | 엔터프라이즈 |
| **New Relic** | 올인원 옵저버빌리티 | 중간~높음 | 다양한 언어 지원 |
| **Jaeger** | 분산 트레이싱 오픈소스 | 무료 | 마이크로서비스 |

#### Sentry (추천 - 에러 모니터링)
```
장점:
- 에러 그룹핑/중복 제거 자동
- 스택 트레이스 + 소스 코드 매핑
- 릴리즈 추적 (어느 버전에서 발생?)
- 무료 플랜 충분

단점:
- 메트릭/로그 기능 약함
- APM 기능 제한적

적합: 에러 모니터링 집중, 프론트엔드+백엔드
```

---

### 4. 알림 (Alerting)

| 도구 | 특징 | 비용 | 적합한 경우 |
|------|------|------|------------|
| **Discord Webhook** | 개발팀 친화적, 스레드 지원 | 무료 | 소규모 팀 |
| **Slack** | 기업 표준, 풍부한 연동 | 무료~중간 | 기업 환경 (미사용) |
| **PagerDuty** | 온콜 로테이션, 에스컬레이션 | 높음 | 24/7 운영 |
| **Opsgenie** | Atlassian, Jira 연동 | 중간 | Jira 사용 팀 |

#### Discord Webhook (MVP 선택)
```
장점:
- 완전 무료
- 설정 매우 간단
- 개발자 친화적 (마크다운, 임베드)
- 스레드로 관련 알림 그룹핑

단점:
- 기업 환경에서 비공식
- 온콜/에스컬레이션 없음
- 모바일 알림 신뢰성?

적합: 스타트업, 사이드 프로젝트, 개발팀
```

---

## 이 프로젝트의 선택 이유

### 현재 상황 분석

```
프로젝트 특성:
- Rust 백엔드 (단일 서버)
- AWS 배포 (EC2/ECS 예상)
- 소규모 팀 (YAPP 프로젝트)
- AI 서비스 (Claude API 의존)

핵심 모니터링 대상:
1. Claude API 호출 실패/지연
2. 인증 오류
3. 데이터베이스 연결 문제
4. 일반 애플리케이션 에러
```

### 선택한 스택

```
┌─────────────────────────────────────────────────────────────┐
│                      선택한 모니터링 스택                    │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Phase 1: Foundation (Week 1-2)                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐   │
│  │  File Logs   │───▶│  Shell Script│───▶│   Discord    │   │
│  │  (JSON)      │    │  (Watcher)   │    │   Webhook    │   │
│  └──────────────┘    └──────────────┘    └──────────────┘   │
│                                                              │
│  Phase 2: MVP (Week 3-4)                                     │
│  - Log Watcher, Discord 알림, 기본 필터링                    │
│                                                              │
│  Phase 3: AI (Week 5-6)                                      │
│  - Claude API 진단, 컨텍스트 수집                            │
│                                                              │
│  Phase 4: Production (Week 7-8)                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐   │
│  │    Loki      │───▶│   Grafana    │───▶│   Discord    │   │
│  │  (or CW Logs)│    │  (Dashboard) │    │              │   │
│  └──────────────┘    └──────────────┘    └──────────────┘   │
│         │                                                    │
│         ▼                                                    │
│  ┌──────────────┐                                            │
│  │  Prometheus  │ ─── 메트릭 (CPU, 메모리, 요청 수)          │
│  └──────────────┘                                            │
│                                                              │
│  Optional                                                    │
│  ┌──────────────┐                                            │
│  │   Sentry     │ ─── 에러 추적 (스택트레이스, 릴리즈)       │
│  └──────────────┘                                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 선택 이유 상세

#### 1. 로그: 파일 → Loki

| 기준 | 파일 로그 (MVP) | Loki (Production) |
|------|----------------|-------------------|
| 설정 복잡도 | ★☆☆☆☆ | ★★★☆☆ |
| 비용 | 무료 | 무료 (셀프호스팅) |
| 검색 기능 | 없음 (grep) | LogQL |
| 시각화 | 없음 | Grafana 대시보드 |
| 확장성 | 단일 서버 | 다중 서버 |

**왜 ELK가 아닌가?**
- 리소스 사용량이 높음 (Elasticsearch)
- 운영 복잡도 높음
- 우리 규모에서 과도함

**왜 CloudWatch Logs가 아닌가?**
- 비용이 쌓임 (저장 + 쿼리)
- AI Agent가 로그를 읽기 어려움 (API 제한)
- Grafana 연동 시 추가 비용

#### 2. 알림: Discord

| 기준 | Discord | PagerDuty |
|------|---------|-----------|
| 비용 | 무료 | $$$ |
| 설정 | 5분 | 1시간+ |
| 온콜 | 없음 | 있음 |
| 개발자 UX | 좋음 | 보통 |

**왜 Discord인가?**
- 팀이 이미 사용 중
- Webhook 설정 가장 간단
- 임베드 메시지로 예쁜 알림
- 무료

**언제 PagerDuty 추가?**
- 24/7 온콜 로테이션 필요 시
- 에스컬레이션 정책 필요 시

#### 3. 메트릭: 후순위 (Prometheus)

**지금 필요 없는 이유:**
- 로그만으로 대부분 문제 감지 가능
- 단일 서버라 복잡한 메트릭 불필요
- 설정 시간 대비 효용 낮음

**나중에 추가할 때:**
```rust
// Prometheus 메트릭 노출
use prometheus::{Counter, Histogram};

lazy_static! {
    static ref HTTP_REQUESTS: Counter = register_counter!(
        "http_requests_total",
        "Total HTTP requests"
    ).unwrap();

    static ref RESPONSE_TIME: Histogram = register_histogram!(
        "http_response_time_seconds",
        "HTTP response time"
    ).unwrap();
}
```

#### 4. APM: 선택적 (Sentry)

**지금 필요 없는 이유:**
- 로그 기반 에러 추적으로 충분
- Rust 에러 처리가 명시적이라 스택트레이스 명확
- 추가 SDK 통합 비용

**나중에 추가하면 좋은 경우:**
- 프론트엔드 에러 추적 필요 시
- 릴리즈별 에러 추적 필요 시
- 사용자 컨텍스트 (누가 에러를 겪었는지) 필요 시

---

## AI 자율 모니터링과의 연계

### 기존 도구 vs AI 모니터링

```
┌─────────────────────────────────────────────────────────────┐
│                    전통적 모니터링                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  [로그] → [규칙 기반 필터] → [알림] → [사람이 분석]          │
│                                                              │
│  한계:                                                       │
│  - 미리 정의된 규칙만 감지                                   │
│  - 알림만 오고, 왜 문제인지 설명 없음                        │
│  - 사람이 직접 로그 분석해야 함                              │
│  - 반복적인 문제도 매번 수동 해결                            │
│                                                              │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    AI 자율 모니터링                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  [로그] → [AI 분석] → [진단 보고서] → [자동 조치 제안]       │
│                              ↓                               │
│                    [이슈 생성] [PR 생성]                     │
│                                                              │
│  장점:                                                       │
│  - 패턴 학습으로 새로운 문제 감지                            │
│  - 근본 원인 분석 자동화                                     │
│  - 해결책 제안 (때로는 자동 수정)                            │
│  - 컨텍스트 기반 진단 (코드 + 히스토리)                      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 왜 기존 도구 + AI인가?

```
Datadog/New Relic도 AI 기능이 있는데 왜 직접 만드는가?

1. 비용
   - Datadog AI: 호스트당 $15+/월
   - 직접 구축: Claude API 호출 비용만 (건당 ~$0.01)

2. 커스터마이징
   - SaaS: 정해진 기능만 사용
   - 직접 구축: 우리 코드베이스에 맞는 진단

3. 자동화 범위
   - SaaS: 알림까지만
   - 직접 구축: 이슈 생성, PR 생성까지

4. 학습
   - SaaS: 블랙박스
   - 직접 구축: 프롬프트 개선으로 정확도 향상
```

### 보완 관계

```
┌──────────────────────────────────────────────────────────────────┐
│                                                                   │
│   Grafana/Loki (로그 저장/시각화)                                 │
│        │                                                          │
│        ▼                                                          │
│   ┌─────────────────────────────────────────────────────────┐    │
│   │              AI 모니터링 레이어                          │    │
│   │                                                          │    │
│   │   [Log Watcher] ─── Loki에서 로그 읽기                   │    │
│   │        │                                                 │    │
│   │        ▼                                                 │    │
│   │   [Diagnostic Agent] ─── Claude로 분석                   │    │
│   │        │                                                 │    │
│   │        ▼                                                 │    │
│   │   [Action] ─── Discord, GitHub, Auto-Fix                 │    │
│   │                                                          │    │
│   └─────────────────────────────────────────────────────────┘    │
│                                                                   │
│   Sentry (선택적)                                                 │
│   - 에러 그룹핑/중복 제거는 Sentry가 더 잘함                      │
│   - AI 모니터링과 병행 가능                                       │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## 단계별 도구 도입 계획

### Phase 1: Foundation (Week 1-2)
```
목표: 로그 기반 구축
도구: 파일 로그 (JSON), 에러 코드 체계, Request ID

비용: $0
복잡도: 낮음
효과: 구조화된 로그 출력

설정:
- tracing-subscriber JSON 포맷
- ErrorCode enum 정의
- Request ID 미들웨어
```

### Phase 2: MVP (Week 3-4)
```
목표: 모니터링 MVP
도구: Log Watcher + Discord Webhook

비용: $0
복잡도: 낮음
효과: 기본 에러 알림, 중복 방지

설정:
- log-watcher.sh (cron 5분)
- discord-alert.sh
- fingerprint 기반 중복 제거
```

### Phase 3: AI (Week 5-6)
```
목표: AI 진단 연동
도구: Claude API + 커스텀 Agent

비용: Claude API (~$10-50/월 예상)
복잡도: 중간
효과: 자동 진단, 근본 원인 분석

설정:
- diagnostic-agent.py
- 컨텍스트 수집 (소스 코드, git 이력)
- 비용 제한 로직 (시간당 최대 10회)
```

### Phase 4: Production (Week 7-8)
```
목표: 자동화 확장
도구: GitHub Issue + Auto-Fix PR + Loki/Grafana (선택)

비용: Claude API (~$30/월)
복잡도: 중간
효과: 자동 이슈 생성, Auto-Fix PR

설정:
- create-issue.sh
- auto-fix.sh (테스트 필수)
- Loki + Grafana (선택)
```

---

## 결론

### 핵심 선택 원칙

1. **단순하게 시작**: 파일 로그 + Discord로 시작
2. **비용 효율**: SaaS보다 오픈소스 우선
3. **점진적 확장**: 필요할 때 도구 추가
4. **AI 레이어 차별화**: 기존 도구가 못하는 자동 진단/수정

### 최종 권장 스택

| 영역 | MVP | Production | 비용 |
|------|-----|------------|------|
| 로그 | 파일 | Loki | $0 (오픈소스) |
| 메트릭 | - | Prometheus | $0 (오픈소스) |
| 알림 | Discord | Discord | $0 (Webhook 무료) |
| AI | Shell Script | Claude Agent | ~$30/월 |
| 시각화 | - | Grafana | $0 (오픈소스) |

### 선택 근거

#### 1. 로그: 파일 → Loki

| 기준 | 파일 (MVP) | Loki (Production) | ELK | CloudWatch |
|------|-----------|-------------------|-----|------------|
| 비용 | $0 | $0 | 높음 (ES 리소스) | 중간 (저장+쿼리) |
| 설정 복잡도 | 없음 | 중간 | 높음 | 낮음 |
| 검색 기능 | grep | LogQL | 풀텍스트 | Insights |
| Grafana 연동 | 불가 | 네이티브 | 플러그인 | 추가 비용 |

**선택 이유**:
- **ELK 제외**: 리소스 사용량 높음, 운영 복잡도 높음, 우리 규모에 과도함
- **CloudWatch 제외**: 비용 누적 (저장 + 쿼리), AI Agent가 로그 읽기 어려움 (API 제한)
- **Loki 선택**: Grafana 네이티브 통합, 라벨 기반 저비용, LogQL로 충분한 쿼리

#### 2. 메트릭: 없음 → Prometheus

| 기준 | Prometheus | CloudWatch Metrics | Datadog |
|------|------------|-------------------|---------|
| 비용 | $0 | 커스텀 메트릭 유료 | $15+/호스트 |
| 표준화 | CNCF 표준 | AWS 종속 | 독자 포맷 |
| Grafana 연동 | 네이티브 | 플러그인 | 별도 대시보드 |

**선택 이유**:
- **MVP에서 제외**: 로그만으로 대부분 문제 감지 가능, 단일 서버라 복잡한 메트릭 불필요
- **Production에서 Prometheus**: 사실상 업계 표준, PromQL 강력, Grafana와 완벽 통합

#### 3. 알림: Discord

| 기준 | Discord | Slack | PagerDuty |
|------|---------|-------|-----------|
| 비용 | $0 | 유료 플랜 권장 | $$$$ |
| 설정 시간 | 5분 | 10분 | 1시간+ |
| 온콜 기능 | 없음 | 없음 | 있음 |
| 팀 사용 여부 | **사용 중** | 미사용 | 미사용 |

**선택 이유**:
- **팀이 이미 Discord 사용 중** → 추가 도구 도입 불필요
- Webhook 설정 가장 간단 (5분)
- 임베드 메시지로 구조화된 알림 가능
- 24/7 온콜이 필요해지면 그때 PagerDuty 검토

#### 4. AI: Shell Script → Claude Agent

| 기준 | Shell Script (MVP) | Claude Agent | Datadog AI |
|------|-------------------|--------------|------------|
| 비용 | $0 | ~$30/월 | $15+/호스트 |
| 진단 깊이 | 패턴 매칭만 | 컨텍스트 기반 | 블랙박스 |
| 자동 수정 | 불가 | 가능 | 불가 |
| 커스터마이징 | 스크립트 수정 | 프롬프트 튜닝 | 불가 |

**선택 이유**:
- **MVP는 Shell Script**: 빠른 구현, 의존성 최소화, 기본 에러 감지에 충분
- **Production은 Claude Agent**:
  - 코드 + 커밋 이력 기반 **근본 원인 분석**
  - 자동 수정 PR 생성 가능
  - 프롬프트 개선으로 정확도 향상 가능
  - SaaS 대비 **비용 효율** (~$30 vs $15+/호스트)

#### 5. 시각화: 없음 → Grafana

| 기준 | Grafana | CloudWatch Dashboard | Datadog Dashboard |
|------|---------|---------------------|-------------------|
| 비용 | $0 | 유료 | 포함 (고가) |
| Loki 연동 | 네이티브 | 불가 | 불가 |
| Prometheus 연동 | 네이티브 | 불가 | 별도 |

**선택 이유**:
- **MVP에서 제외**: 터미널/로그 직접 확인으로 충분, 대시보드 구축 시간 절약
- **Production에서 Grafana**: Loki + Prometheus와 **동일 생태계**, 오픈소스로 비용 $0

---

### 비용 요약

| 환경 | 월 비용 |
|------|---------|
| **MVP** | **$0** |
| **Production** | **~$30/월** (Claude API만) |

**유일한 비용: Claude API 호출**
- Sonnet: 1회 진단 ≈ $0.01
- Haiku 사용 시: 1회 ≈ $0.001 (10배 저렴)
- 하루 100회 진단 = 월 ~$30

**인프라 비용 $0 가능**: 기존 서버에 Loki/Prometheus/Grafana를 Docker Compose로 함께 배포

(비교: Datadog Pro = 호스트당 $23/월 + 로그 $0.10/GB → 우리 스택 대비 **10배 이상 비용**)
